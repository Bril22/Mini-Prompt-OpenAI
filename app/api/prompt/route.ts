import { NextRequest } from "next/server";

export const runtime = "edge";

export async function POST(req: NextRequest) {
    const { messages, model } = await req.json();
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
        return new Response(JSON.stringify({ error: "Messages array is required." }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
        });
    }
    const apiKey = process.env.OPEN_API_KEY;
    const modelToUse = typeof model === "string" && model ? model : "gpt-3.5-turbo";
    const mockResponses = [
        'This is a mock response since no OpenAI API key is configured. Your prompt was: "' + messages[messages.length - 1]?.content + '"',
        "Mock AI Response: I understand you're testing the prompt system. This would normally be generated by " + modelToUse + ".",
        "Simulated response: Thank you for your prompt! In a real scenario, this would be processed by OpenAI's " + modelToUse + " model.",
        "Demo response: Your prompt has been received and would typically generate a contextual response using the selected AI model.",
    ];
    if (!apiKey) {
        const randomMock = mockResponses[Math.floor(Math.random() * mockResponses.length)];
        return new Response(randomMock, {
            headers: { "Content-Type": "text/plain; charset=utf-8" },
        });
    }
    try {
        const openaiRes = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`,
            },
            body: JSON.stringify({
                model: modelToUse,
                messages: [
                    { role: "system", content: "You are a helpful assistant." },
                    ...messages,
                ],
                max_tokens: 256,
                temperature: 0.7,
                stream: true,
            }),
        });
        if (!openaiRes.ok || !openaiRes.body) {
            const randomMock = mockResponses[Math.floor(Math.random() * mockResponses.length)];
            return new Response(randomMock, {
                headers: { "Content-Type": "text/plain; charset=utf-8" },
            });
        }
        // Stream OpenAI response to client
        const encoder = new TextEncoder();
        const stream = new ReadableStream({
            async start(controller) {
                if (!openaiRes.body) {
                    controller.close();
                    return;
                }
                const reader = openaiRes.body.getReader();
                let buffer = "";
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += new TextDecoder().decode(value);
                        // Parse and forward only the content delta
                        const lines = buffer.split("\n");
                        buffer = lines.pop() || "";
                        for (const line of lines) {
                            const trimmed = line.trim();
                            if (!trimmed || !trimmed.startsWith("data:")) continue;
                            const data = trimmed.replace("data:", "").trim();
                            if (data === "[DONE]") {
                                controller.close();
                                return;
                            }
                            try {
                                const json = JSON.parse(data);
                                const content = json.choices?.[0]?.delta?.content;
                                if (content) {
                                    controller.enqueue(encoder.encode(content));
                                }
                            } catch { }
                        }
                    }
                } catch (err) {
                    controller.error(err);
                }
            },
        });
        return new Response(stream, {
            headers: {
                "Content-Type": "text/plain; charset=utf-8",
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Transfer-Encoding": "chunked",
            },
        });
    } catch (err) {
        const randomMock = mockResponses[Math.floor(Math.random() * mockResponses.length)];
        return new Response(randomMock, {
            headers: { "Content-Type": "text/plain; charset=utf-8" },
        });
    }
}